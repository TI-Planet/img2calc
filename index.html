<!doctype html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <title>ConvertImg</title>
    <style type="text/css">
        body {
            font-family:-apple-system,BlinkMacSystemFont,"Lucida Grande","Trebuchet MS",Verdana,Helvetica,Arial,sans-serif;
            text-align:center;
            margin:0
        }

        #mainContent {
            max-width:80%;
            margin:auto
        }

        .file {
            border:2px dashed #777;
            border-radius:20px;
            max-width:70%;
            margin:30px auto;
            padding:20px
        }

        p {
            margin-top:0
        }

        .my-form {
            margin-bottom:10px
        }

        .button {
            display:inline-block;
            padding:10px;
            background:#ccc;
            cursor:pointer;
            border-radius:5px;
            border:1px solid #ccc
        }

        .button:hover {
            background:#ddd
        }

        #fileElem {
            display:none
        }

        .img {
            width:49%;
            min-height:320px;
            border:1px dotted #bbb;
            border-radius:10px
        }

        #inFrame {
            float:left;
            left:0;
            background:repeating-linear-gradient(45deg,#ddd,#fff 10px,#ddd 20px)
        }

        #outFrame {
            float:right;
            right:0;
            background:repeating-linear-gradient(-45deg,#ddd,#fff 10px,#ddd 20px)
        }
    </style>
</head>
<body>

<br>
<div>
    <b>Format:</b>
    <form id="formatChoice">
        <input type="radio" id="im8c" name="type" value="im8c" checked><label for="im8c">IM8C (Python)</label>&nbsp;
        <input type="radio" id="8ca" name="type" value="8ca"><label for="8ca">8CA</label>&nbsp;
        <input type="radio" id="8ci" name="type" value="8ci"><label for="8ci">8CI</label>&nbsp;
        <input type="radio" id="8xi" name="type" value="8xi"><label for="8xi">8XI</label>&nbsp;
    </form>
</div>
<br>

<script type="module">
    //import * as Magick from './magick/magickApi.js';
    import * as Magick from 'https://knicknic.github.io/wasm-imagemagick/magickApi.js';

    let outWidth = 0;
    let outHeight = 0;
    let convType = "im8c";
    let inFileName = "";
    let paletteFile = [];
    let palette_a = [];

    function getType() {
        return document.querySelector("#formatChoice input:checked").value;
    }

    function handlePaletteURL(file) {
        paletteFile = [];
        const paletteImg = new Image();
        paletteImg.src = file;
        paletteImg.onload = function () {
            handlePaletteImg(paletteImg);
        };
    }

    function handlePaletteImg(img) {
        const canvas = document.getElementById('paletteCanvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const context = canvas.getContext('2d');
        context.drawImage(img, 0, 0);
        const imgData = context.getImageData(0, 0, img.width, img.height);
        const imgBuffer = imgData.data.buffer;
        palette_a = new Uint8Array(imgBuffer);
        canvas.toBlob(handlePaletteCanvas);
    }

    async function handlePaletteCanvas(blob) {
        const sourceBytes = await blob.arrayBuffer();
        const localName = "palette.png";
        paletteFile = [{'name': localName, 'content': sourceBytes}];
    }

    function handleInFile(file) {
        convType = getType();
        if (convType === "8ci") handlePaletteURL("./pal8ci.png");
        const fileReader = new FileReader();
        fileReader.onload = handleInFileData;
        fileReader.readAsDataURL(file);
        inFileName = file['name'];
    }

    function handleInFileData(file) {
        const inImg = new Image();
        inImg.src = file.target.result;
        inImg.onload = function () {
            handleInImg(inImg);
        };
    }

    function handleInImg(img) {
        const canvas = document.getElementById('inImgCanvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const context = canvas.getContext('2d');
        context.drawImage(img, 0, 0);
        canvas.toBlob(handleInCanvas);
    }

    async function handleInCanvas(blob) {
        if (convType === "8ci" && paletteFile.length === 0) {
            setTimeout(handleInCanvas, 100, blob);
            return;
        }
        const sourceBytes = await blob.arrayBuffer();
        const localName = "input.png";
        let files = [{'name': localName, 'content': sourceBytes}];
        let command;
        if (convType === "im8c") {
            [outWidth, outHeight] = [320, 210];
            command = ["convert", localName, "-channel", "red", "-depth", "5", "-channel", "green", "-depth", "6", "-channel", "blue", "-depth", "5", "-channel", "alpha", "-depth", "1", "-resize", `${outWidth}x${outHeight}>`, "-colors", "256", "out.png"];
        } else if (convType === "8ca") {
            [outWidth, outHeight] = [134, 83];
            command = ["convert", localName, "-background", "white", "-flatten", "-resize", `${outWidth-1}x${outHeight}!`, "-gravity", "northeast", "-splice", "1x0", "out.png"];
        } else if (convType === "8ci") {
            [outWidth, outHeight] = [266, 165];
            files = files.concat(paletteFile);
            command = ["convert", localName, "-resize", `${outWidth-1}x${outHeight}!`, "-remap", "palette.png", "-gravity", "northeast", "-splice", "1x0", "out.png"];
        } else if (convType === "8xi") {
            [outWidth, outHeight] = [96, 63];
            command = ["convert", localName, "-background", "white", "-flatten", "-resize", `${outWidth-1}x${outHeight}!`, "-colorspace", "Gray", "-auto-level", "-posterize", "2", "-gravity", "northeast", "-splice", "1x0", "-transparent", "white", "out.png"];
        }
        const processedFiles = await Magick.Call(files, command);
        const firstOutputImg = processedFiles[0];

        const inImg = document.getElementById("inImg");
        inImg.src = URL.createObjectURL(blob);
        inImg.style.maxWidth = `${outWidth}px`;
        inImg.style.maxHeight = `${outHeight}px`;
        const outImg = document.getElementById("outImg");
        outImg.onload = function () {
            handleOutImg(outImg);
        };
        outImg.src = URL.createObjectURL(firstOutputImg['blob']);
    }

    function getRawPixel(img, i) {
        i *= 4;
        return [img[i], img[i + 1], img[i + 2], img[i + 3]];
    }

    function getPixel(img, i, r, g, b, a) {
        i *= 4;
        return img[i + 2] >> (8 - r) | img[i + 1] >> (8 - g) << r | img[i] >> (8 - b) << (r + g) | img[i + 3] >> (8 - a) << (r + g + b);
    }

    function handleOutImg(img) {
        const canvas = document.getElementById('outImgCanvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const context = canvas.getContext('2d');
        context.drawImage(img, 0, 0);
        const imgData = context.getImageData(0, 0, img.width, img.height);
        const imgBuffer = imgData.data.buffer;  // ArrayBuffer
        const img_a = new Uint8Array(imgBuffer);
        let data = [];

        switch (convType)
        {
            case "im8c": {
                const paletteRGBA_a = [];
                let ialpha = -1;
                const r = 5, g = 6, b = 5, a = 1;
                for (let i = 0; i < img.height * img.width; i++) {
                    const color = getPixel(img_a, i, r, g, b, a);
                    if (paletteRGBA_a.indexOf(color) < 0) {
                        const icolor = paletteRGBA_a.length;
                        paletteRGBA_a.push(color);
                        if (ialpha < 0 && !(color >> (r + g + b))) {
                            ialpha = icolor;
                        }
                    }
                }
                const paletteHeader_a = [];
                if (ialpha < 0) {
                    paletteHeader_a.push(1, 0, 0);
                } else {
                    paletteHeader_a.push(1, 1, ialpha & 0xFF);
                }
                paletteHeader_a.push(paletteRGBA_a.length & 0xFF);

                const paletteRGB_a = [];
                for (let i = 0; i < paletteRGBA_a.length; i++) {
                    const color = paletteRGBA_a[i] & 0xFFFF;
                    paletteRGB_a.push(color & 0xFF, color >> 8);
                }
                const dataRLE_a = [];
                let pixBuffer_a = [];
                for (let i = 0; i < img.height * img.width; i++) {
                    const curcolor = getPixel(img_a, i, r, g, b, a);
                    const icolor = paletteRGBA_a.indexOf(curcolor);
                    let ncurcolor = 1;
                    while (ncurcolor < 128 && i < img.height * img.width - 1 && curcolor === getPixel(img_a, i + 1, r, g, b, a)) {
                        ncurcolor++;
                        i++;
                    }
                    if (ncurcolor > 1) {
                        while (pixBuffer_a.length) {
                            const n = Math.min(pixBuffer_a.length, 128);
                            dataRLE_a.push(n - 1);
                            for (let j = 0; j < n; j++) {
                                dataRLE_a.push(pixBuffer_a[j]);
                            }
                            pixBuffer_a = pixBuffer_a.slice(n);
                        }
                        dataRLE_a.push(0x80 + ncurcolor - 2, icolor);
                    } else {
                        pixBuffer_a.push(icolor);
                    }
                }
                data = [].concat(
                    str2charCodeArray("IM8C"),
                    int2LittleEndianArray(img.width, 3),
                    int2LittleEndianArray(img.height, 3),
                    paletteHeader_a,
                    paletteRGB_a,
                    dataRLE_a,
                );
                break;
            }

            case "8ca": {
                const r = 5, g = 6, b = 5, a = 0;
                data.push(0x81);
                for (let i = 0; i < img.height * img.width; i++) {
                    const color = getPixel(img_a, outWidth * (outHeight - Math.floor(i / outWidth) - 1) + (i % outWidth), r, g, b, a);
                    data.push(color & 0xFF, color >> 8);
                }
                break;
            }

            case "8ci": {
                const paletteRGBA_a = [];
                for (let i = 0; i < palette_a.length / 4; i++) {
                    const color = getRawPixel(palette_a, i);
                    paletteRGBA_a.push(color);
                }

                // workaround - although the colors are correct if checked on the ouput <img> screen capture
                // RGBA colors in the output canvas Uint8Array(canvas.data.buffer) can slightly differ
                const nearestiRGB = function(color, palette) {
                    let min = 4 * 255 + 1;
                    let imin = -1;
                    for (let i = 0; i < palette.length; i++) {
                        const v = Math.abs(palette[i][0] - color[0]) + Math.abs(palette[i][1] - color[1]) + Math.abs(palette[i][2] - color[2]) + Math.abs(palette[i][3] - color[3]);
                        if (v < min) {
                            imin = i;
                            min = v;
                        }
                    }
                    return imin;
                }

                for (let i = 0; i < img.height * img.width; i += 2) {
                    let icolor = 0;
                    for (let j = 0; j < 2; j++) {
                        const color = getRawPixel(img_a, i + j);
                        icolor = (icolor << 4) | nearestiRGB(color, paletteRGBA_a);
                    }
                    data.push(icolor);
                }
                break;
            }

            case "8xi": {
                for (let i = 0; i < img.height * img.width; i += 8) {
                    let icolor = 0;
                    for (let j = 0; j < 8; j++) {
                        const color = getPixel(img_a, i + j, 0, 0, 0, 1);
                        icolor = (icolor << 1) | color;
                    }
                    data.push(icolor);
                }
                break;
            }

            default:
                const err = "Unsupported conversion type";
                alert(err);
                throw err;
        }

        data = [].concat(
            int2LittleEndianArray(data.length, 2),
            data
        );

        let name = "";
        let calcname = "";
        if (convType === "im8c") {
            name = inFileName;
            const iname = name.indexOf('.');
            if (iname >= 0) name = name.substring(0, iname);
            name = name.substring(0, 1).toUpperCase() + name.substring(1, 8);
            let cond = '(8 alphanumerical characters max, 1st must be uppercase letter)';
            do {
                name = prompt(`Enter oncalc variable name - ${cond}`, name);
                if (name === null) {
                    return;
                } // early exit if the dialog was cancelled
                if (!name || (!/^[A-Z][a-zA-Z0-9_]{0,7}$/.test(name))) alert(cond);
            } while (!name || !/^[A-Z][a-zA-Z0-9_]{0,7}$/.test(name));
            calcname = name;
        } else if (convType === "8ca" || convType === "8ci" || convType === "8xi") {
            const cond = '(0-9)';
            do {
                name = prompt(`Enter oncalc image number - ${cond}`, name);
                if (name === null) {
                    return;
                } // early exit if the dialog was cancelled
                if (!name || (!/^[0-9]$/.test(name))) alert(cond);
            } while (!name || !/^[0-9]$/.test(name));
            let num = name - "0";
            calcname = `${(convType === "8ca") ? "Image" : "Pic"}${num}`;
            if (num === 0) num = 10;
            name = String.fromCharCode((convType === "8ca") ? 0x3C : 0x60, num - 1);
        }

        const nameArray = str2charCodeArray(padStr(name, 8, String.fromCharCode(0)));
        const size2 = int2LittleEndianArray(data.length, 2);
        data = [].concat(
            [0x0D, 0x00],
            size2,
            [(convType === "im8c") ? 0x15 : (convType === "8ca") ? 0x1A : (convType === "8ci" || convType === "8xi") ? 0x07 : 0x00],
            nameArray,
            [(convType === "8ca" || convType === "8ci") ? 0x0A : 0x00, (convType === "8xi") ? 0x00 : 0x80],
            size2,
            data,
        );

        data = [].concat(
            str2charCodeArray("**TI83F*"),
            [0x1A, 0x0A, (convType === "im8c") ? 0x0A : (convType === "8ci") ? 0x0F : (convType === "8xi") ? 0x0B : 0x00],
            str2charCodeArray(padStr("Created on TI-Planet.org by img2calc", 42, String.fromCharCode(0))),
            int2LittleEndianArray(data.length, 2),
            data,
            int2LittleEndianArray(crcti8x(data), 2),
        );

        addBlobFileLink(new Uint8Array(data), `${calcname}${(convType === "im8c") ? ".8xv" : `.${convType}`}`, document.getElementById("fileList"));
    }

    function crcti8x(data) {
        return data.reduce((a, b) => a + b, 0) & 0xFFFF;
    }

    function padStr(str, n, char) {
        str = str.substring(0, n);
        while (str.length < n)
            str += char;
        return str;
    }

    function int2LittleEndianArray(v, n) {
        const array = [];
        for (let i = 0; i < n; i++) {
            array.push(v & 0xff);
            v >>= 8;
        }
        return array;
    }

    function str2charCodeArray(str) {
        const array = [];
        for (let i = 0; i < str.length; i++)
            array.push(str.charCodeAt(i));
        return array;
    }

    function addBlobFileLink(file, name, parent) {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = window.URL.createObjectURL((new Blob([file], {type: 'application/octet-stream'})));
        a.download = name;
        a.innerText = name;
        li.appendChild(a);
        parent.appendChild(li);
    }

    if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
        alert("Reading files not supported by this browser");
    } else {
        window.handleInFile = handleInFile;
    }
</script>

<div id="mainContent">
    <div id="inFrame" class="img">
        <br>
        <p><b>Source image:</b></p>
        <img id="inImg" alt="" src=""/>
        <div id="inFile" class="file">
            <form class="my-form">
                <p>Choose your image file</p>
                <input type="file" id="fileElem" accept="image/*" onchange="handleInFile(this.files[0])">
                <label class="button" for="fileElem">Select the image</label>
            </form>
        </div>
    </div>
    <div id="outFrame" class="img">
        <br>
        <p><b>Converted image:</b></p>
        <img id="outImg" alt="" src=""/>
        <div id="outFile" class="file">
            <ul id="fileList"></ul>
        </div>
    </div>
    <canvas id="inImgCanvas" style="display:none"></canvas>
    <canvas id="outImgCanvas" style="display:none"></canvas>
    <canvas id="paletteCanvas" style="display:none"></canvas>
</div>

</body>
</html>